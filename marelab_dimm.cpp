// Do not remove the include below
#include <stdlib.h>

#include "marelab_dimm.h"
#include "OLED.h"

/* Main.ino file generated by New Project wizard
 *
 * Created:   Thu Sep 5 2013
 * Processor: ATmega328P
 * Compiler:  Arduino AVR
 */

/*********************************************************************
This is the marelab Led Pwm & RTC Dimmer.
The firmeware works in a standalone mode and can drive 16 PWM channels
It has an onboard RTC and RS485 Interface to connect to the marelab
master System for easy Config and automatic controlling.
In standalone Modus every channel has 4 Time stamps in seconds to
define:
    DIM_START_MIN    defines startpoint in sec. PWM val = 0
    DIM_START_MAX    defines startendpoint in sec.
    DIM_START_VALUE  PWM value for startendpoint
    DIM_END_MAX      defines endpoint in sec.
    DIM_END_VALUE    PWM value for endpoint
    DIM_END_MIN;     defines endpoint in sec. PWM val = 0

These values are stored in the EEPROM. If there are more Graph Points
defined via the Mastercontrol only the two first and two last
timepoints are stored in the EEprom.

*********************************************************************/
#define MODBUS_BAUD			115200	/* Modbus Baud */
#define MARELAB_TYPE			1	/* Set the device ID to get identified 	*/
#define MARELAB_FIRWMARE  		2
#define MODBUS_REGISTER_COUNT 	30  /* COUNT of Modbus to Led Registers starting with 0 */

/* These are the Modbus Registers where we can read & write to        */
/* Mapping Modbus Register to LED Lamp Functions */
#define MARELAB_DEVICE_ID 		0	/* Device ID to identify marelab 	*/
#define MARELAB_VERSION			1	/* Firmware ID to identify 		*/
#define MARELAB_REGISTER_COUNT  2
#define LED_COLOR1 				3	/* DIM Value channel 1			*/
#define LED_COLOR2 				4
#define LED_COLOR3 				5
#define LED_COLOR4 				6
#define LED_COLOR5 				7
#define LED_COLOR6 				8
#define LED_COLOR7 				9
#define LED_COLOR8 				10
#define LED_COLOR9 				11
#define LED_COLOR10 			12
#define LED_COLOR11 			13
#define LED_COLOR12 			14
#define LED_COLOR13 			15
#define LED_COLOR14 			16
#define LED_COLOR15 			17
#define LED_COLOR16 			18
#define DIMM_TEMPERATUR 		19	/* Chassi temperature of the dimmer	*/
#define UNIX_DATE1				20	/* Timestap high of Dimmer RTC		*/
#define UNIX_DATE2				21	/* Timestap low  of Dimmer RTC		*/
#define MCOMMAND        		22
/*
  0 nothing
  1 free
  2 setRTC Time
  10 setPWM fills 20-26
  11 getPWM fills 20-26 Two reads
  20 getTemp Sensor 1
  21 getTemp Sensor 2
*/
#define MDIM_START_MIN   		23  	/* defines startpoint in sec. PWM val = 0 */
#define MDIM_START_MAX   		24 		/* defines startendpoint in sec.  */
#define MDIM_START_VALUE 		25 		/* PWM value for startendpoint */
#define MDIM_END_MAX     		26 		/* defines endpoint in sec. */
#define MDIM_END_VALUE   		27 		/* PWM value for endpoint */
#define MDIM_END_MIN     		28 		/* defines endpoint in sec. PWM val = 0 */
#define MDIM_CHANNEL     		29 		/* the dimchannel the values belongs to */

#define I2C_ADRESS_MODBUS_ADR	0x38

uint16_t mb_reg[MODBUS_REGISTER_COUNT];

#define OLED_RESET 		4
#define NUMFLAKES 		10
#define XPOS 			0
#define YPOS 			1
#define DELTAY 			2

PCF8574 PCF_38(I2C_ADRESS_MODBUS_ADR);	/* Modbus Adress I2C Switch extender */

uint8_t  MODBUS_SLAVE_ID;				/* Slave ID of this device 			*/
OLED screen;							/* marelab Graphic Lib 				*/
//ModbusinoSlave mb;						/* Modbus Object 					*/
#ifndef SIMULATION
	RTC_DS1307 rtc;		/* RealTime Clock Object 			*/
#endif
uint8_t draw_state = 0;					/* Global Graphic Display State 	*/

const int ledPin = 13;

unsigned int MODCODES=0;

OneWire  ds(10);


struct DimChannel
{
    uint16_t DIM_START_MIN;
    uint16_t DIM_START_MAX;
    uint16_t DIM_START_VALUE;
    uint16_t DIM_END_MAX;
    uint16_t DIM_END_VALUE;
    uint16_t DIM_END_MIN;
};


void TimeToModBusRegister(DateTime time){
   const long LOW_MASK = ((1L << 32) - 1);
   mb_reg[UNIX_DATE1]=(uint16_t)(time.unixtime() >> 16);
   mb_reg[UNIX_DATE2]=(uint16_t)(time.unixtime() & LOW_MASK);
  }

int32_t MakeTime(  uint16_t highv,  uint16_t lowv){
   uint32_t caltime;
   caltime = ((uint32_t)highv << 16) | lowv;
   return caltime;
}

// Calculate the percent dim value for 100% as value of a 16 Bit Dim Register
int8_t PercentDim(uint16_t dimvalue){
   return dimvalue/((1024 / 100)) ;
}

// Calculate the percent dim value for GRAPH 100% = 32px
int8_t PercentGraphDim(uint16_t dimvalue){
   return dimvalue/32;
}
// For 128x64 Pixel
void DrawLedGraph(void) {
  uint8_t yh = 40;   // Max height of a bar
  uint8_t y=0;
  uint16_t yscale= 1024/yh;
  uint16_t reg;

  screen.DrawLine(20,63,20,(63-yh));
  screen.DrawLine(18,63,127,63);  //0 %
  screen.Text(0,56,"0");
  screen.DrawLine(18,43,127,43);  //50 %
  screen.Text(0,40,"50");
  screen.DrawLine(18,23,127,23);  //100 %
  screen.Text(0,20,"100");
  screen.DrawLine(20,63,127,63);
  screen.DrawLine(127,63,127,(63-40));
//*  display.fillRect(22, 30, 94, 31 , BLACK);
  for (uint8_t i=LED_COLOR1; i<19; i++) {
    // scaling the 10Bit 1024 Value to y achse
    reg = mb_reg[i];
    y = reg/yscale;
    //screen.DrawFilledRect(((i-LED_COLOR1)*6)+22, yh+(yh-y), 4, y );
    screen.DrawFilledRect(((i-LED_COLOR1)*6)+26, 63-y, 4, 63 );
  }

}

void DisplayStatus() {

	char buffer [4];
	//display.setTextColor(WHITE);
	//clear_screen();
	//drawSolidRectangle(45, 12, 96, 8 );


	// RTC Date & Time
#ifndef SIMULATION
	DateTime now = rtc.now();
	TimeToModBusRegister(now);
	itoa (now.hour(),buffer,10);
	screen.Text(85,5,buffer);
	screen.Text(95,5,":");
	itoa (now.minute(),buffer,10);
	screen.Text(100,5,buffer);
	screen.Text(110,5,":");
	itoa (now.second(),buffer,10);
	screen.Text(115,5,buffer);
#endif
	// Modbus ID
	screen.Text(35, 5, "ID:");
	itoa (MODBUS_SLAVE_ID,buffer,10);
	screen.Text(51, 5, buffer);
	// CODE

	// Temperatur of Dimmer Hardware
	screen.Text(0,5,"T:");
	itoa (mb_reg[DIMM_TEMPERATUR],buffer,10);
	screen.Text(11,5,buffer);
	screen.Text(24,5,"C");

	// Graph of 16 LEDs
	DrawLedGraph();
	screen.Show();
}


void Logo(){

	screen.DrawXBM(10,20,104,20,marelab_logo);
	screen.Show();


}

void draw(void) {

	screen.firstPage();
	do {
		switch(draw_state) {
			case 0: Logo(); break;
			case 1: DisplayStatus(); break;
		}
	}while( screen.nextPage() );

}

void setup() {
	screen.begin();
	draw();
	delay(2000);
	draw_state= 1;

#ifdef SIMULATION
	MODBUS_SLAVE_ID = 7;		//!!!! Solange Hardware nicht ready ist
#else
//	MODBUS_SLAVE_ID = PCF_38.read8();
#endif
	mb_reg[MARELAB_DEVICE_ID]= MARELAB_TYPE;				/* Set the device ID to get identified 	*/
	mb_reg[MARELAB_VERSION]= MARELAB_FIRWMARE;				/* Set the Firmware Version ID 			*/
	mb_reg[MARELAB_REGISTER_COUNT]= MODBUS_REGISTER_COUNT;	/* Stores the amount of registers for modbus */

	mb_reg[LED_COLOR1]= 100;
	mb_reg[LED_COLOR2]= 200;
	mb_reg[LED_COLOR3]= 300;
	mb_reg[LED_COLOR4]= 400;
	mb_reg[LED_COLOR5]= 500;
	mb_reg[LED_COLOR6]= 600;
	mb_reg[LED_COLOR7]= 700;
	mb_reg[LED_COLOR8]=800;
	mb_reg[LED_COLOR9]= 900;
	mb_reg[LED_COLOR10]= 1000;
	mb_reg[LED_COLOR11]= 900;
	mb_reg[LED_COLOR12]= 800;
	mb_reg[LED_COLOR13]= 700;
	mb_reg[LED_COLOR14]= 600;
	mb_reg[LED_COLOR15]= 500;
	mb_reg[LED_COLOR16]= 400;

	mb_reg[DIMM_TEMPERATUR]=48;
	mb_reg[UNIX_DATE1]= 0;
	mb_reg[UNIX_DATE2]= 0;
	mb_reg[MCOMMAND]= 0;

	// Reading EEPROM
	DimChannel DimChSet;
	EEPROM_readAnything(0, DimChSet);
	mb_reg[MDIM_START_MIN]= DimChSet.DIM_START_MIN;
	mb_reg[MDIM_START_MAX]= DimChSet.DIM_START_MAX;
	mb_reg[MDIM_START_VALUE]= DimChSet.DIM_START_VALUE;
	mb_reg[MDIM_END_MAX]= DimChSet.DIM_END_MAX;
	mb_reg[MDIM_END_VALUE]= DimChSet.DIM_END_VALUE;
	mb_reg[MDIM_END_MIN]= DimChSet.DIM_END_MIN;
	mb_reg[MDIM_CHANNEL]= 0;



	//modbusino_slave.setup(MODBUS_BAUD);		/* ModBus Baud Rate			*/
	pinMode(4, OUTPUT);
	modbus_configure(MODBUS_BAUD,MODBUS_SLAVE_ID,4,MODBUS_REGISTER_COUNT,0);


#ifndef SIMULATION
	if (!rtc.begin()) {
	}
	else{
	}
#endif

	// Set ledPin mode
	pinMode(13, OUTPUT);
	//pinMode(4, OUTPUT);
}
byte byteRead;

void loop() {


   //modbusino_slave.loop(LAMP_REGISTER, MODBUS_REGISTER_COUNT);
	/*
	 * if (Serial.available()) {

	    byteRead = Serial.read();
	    digitalWrite(4, HIGH);
	    //delay(1);
	    Serial.write(byteRead);
	    Serial.flush();
	    //delay(1);
	    digitalWrite(4, LOW);
	  }
	  */
	  if ( modbus_update(mb_reg) < 0)
   //if (  mb.Hreg( LED_COLOR1 ) < 1)
      digitalWrite(13, HIGH);
	//else
	//  digitalWrite(13, LOW);

   // Command Interpreter
   // Executes the command in transfered in the command
   // register. After executen it is set to 0
   /* MCOMMAND -> 1  = getRTC Time			*/
   if ( mb_reg[MCOMMAND] == 1 )
   {

   }
   /* MCOMMAND -> 2  = setRTC Time			*/
   else if (  mb_reg[ MCOMMAND ] == 2 )
   {
     DateTime newTime(MakeTime(mb_reg[ UNIX_DATE1 ],mb_reg[ UNIX_DATE2 ]));
     //rtc.adjust(newTime);
   }
   /* MCOMMAND -> 10  = setPWM fills Register 20-26	    */
   /* Writes the DIMM Parameter for a PWM Channel to EEPROM */
   else if ( mb_reg[ MCOMMAND ] == 10 )
   {
      uint16_t chandel2update;
      DimChannel DimChSet;
      DimChSet.DIM_START_MIN  	= mb_reg[ MDIM_START_MIN ];
      DimChSet.DIM_START_MAX	= mb_reg[ MDIM_START_MAX ];
      DimChSet.DIM_START_VALUE	= mb_reg[ MDIM_START_VALUE ];
      DimChSet.DIM_END_MAX	= mb_reg[  MDIM_END_MAX ];
      DimChSet.DIM_END_VALUE	= mb_reg[ MDIM_END_VALUE ];
      DimChSet.DIM_END_MIN	= mb_reg[ MDIM_END_MIN ];
      chandel2update 		= mb_reg[ MDIM_CHANNEL];
      EEPROM_writeAnything((chandel2update *12), DimChSet);
   }
    /* MCOMMAND -> 11  = getPWM fills Register 20-26						*/
    /* Reads the PWM Channel Dimm Values from EEPROM    					*/
    /* To read the registers correct we need two Requests 					*/
    /* 1.) write MultipleRegisters with command (11) -> get and PWM Chanel (MDIM CHANNEL) 	*/
    /*        Program transfers EEPROM content to the Register for reading			*/
    /* 2.) read ReadHoldingRegister (03) -> transfers the PWM Channel Data			*/
   else if ( mb_reg[  MCOMMAND ] == 11 )
   {
      uint16_t chandel2update;
      chandel2update 			= mb_reg[ MDIM_CHANNEL ];
      DimChannel DimChSet;
      EEPROM_readAnything((chandel2update *12), DimChSet);
      mb_reg[ MDIM_START_MIN ]= 	DimChSet.DIM_START_MIN;
      mb_reg[ MDIM_START_MAX]=		DimChSet.DIM_START_MAX;
      mb_reg[  MDIM_START_VALUE]=DimChSet.DIM_START_VALUE;
      mb_reg[ MDIM_END_MAX]= DimChSet.DIM_END_MAX;
      mb_reg[ MDIM_END_VALUE]=DimChSet.DIM_END_VALUE;
      mb_reg[ MDIM_END_MIN]= DimChSet.DIM_END_MIN;
     }

   mb_reg[MCOMMAND]= 0;   /* after each loop setting the modbus command register to 0 */
   draw();
}
